use serde::Deserialize;
use std::io::{BufRead, BufReader, Seek, SeekFrom};
use std::path::PathBuf;
use std::process::Command;
use std::sync::mpsc;
use std::time::Duration;

use ftui_runtime::subscription::{StopSignal, SubId, Subscription};

use crate::msg::Msg;

// --- Data types matching `gt status --json` output ---

#[derive(Debug, Clone, Default, Deserialize)]
pub struct TownStatus {
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub overseer: Overseer,
    #[serde(default)]
    pub agents: Vec<AgentInfo>,
    #[serde(default)]
    pub rigs: Vec<RigStatus>,
    #[serde(default)]
    pub summary: StatusSummary,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct Overseer {
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub unread_mail: u32,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct StatusSummary {
    #[serde(default)]
    pub rig_count: u32,
    #[serde(default)]
    pub polecat_count: u32,
    #[serde(default)]
    pub crew_count: u32,
    #[serde(default)]
    pub active_hooks: u32,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct RigStatus {
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub polecat_count: u32,
    #[serde(default)]
    pub crew_count: u32,
    #[serde(default)]
    pub has_witness: bool,
    #[serde(default)]
    pub has_refinery: bool,
    #[serde(default)]
    pub agents: Vec<AgentInfo>,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct AgentInfo {
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub address: String,
    #[serde(default)]
    pub session: String,
    #[serde(default)]
    pub role: String,
    #[serde(default)]
    pub running: bool,
    #[serde(default)]
    pub has_work: bool,
    #[serde(default)]
    pub state: String,
    #[serde(default)]
    pub unread_mail: u32,
}

#[derive(Debug, Clone, Default, Deserialize)]
#[allow(dead_code)]
pub struct ConvoyItem {
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub title: String,
    #[serde(default)]
    pub status: String,
    #[serde(default)]
    pub created_at: String,
    #[serde(default)]
    pub progress: String,
    #[serde(default)]
    pub total: u32,
    #[serde(default)]
    pub done: u32,
    #[serde(default)]
    pub landed: bool,
}

#[derive(Debug, Clone, Default)]
pub struct GtEvent {
    pub timestamp: String,
    pub event_type: String,
    pub actor: String,
    pub message: String,
}

// --- Beads types matching `bd --no-db ready/list/blocked --json` ---

#[derive(Debug, Clone, Default, Deserialize)]
pub struct BeadItem {
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub title: String,
    #[serde(default)]
    pub description: String,
    #[serde(default)]
    pub status: String,
    #[serde(default)]
    pub priority: u8,
    #[serde(default)]
    pub issue_type: String,
    #[serde(default)]
    pub labels: Vec<String>,
    #[serde(default)]
    pub assignee: String,
    #[serde(default)]
    pub estimated_minutes: Option<u32>,
    #[serde(default)]
    pub dependency_count: u32,
    #[serde(default)]
    pub dependent_count: u32,
    #[serde(default)]
    pub blocked_by_count: u32,
    #[serde(default)]
    pub blocked_by: Vec<String>,
    #[serde(default)]
    pub created_at: String,
    #[serde(default)]
    pub updated_at: String,
}

/// Snapshot of beads data: ready, in-progress, and blocked lists.
#[derive(Debug, Clone, Default)]
pub struct BeadsSnapshot {
    pub ready: Vec<BeadItem>,
    pub in_progress: Vec<BeadItem>,
    pub blocked: Vec<BeadItem>,
    pub total_count: u32,
}

// --- Mail types matching `gt mail inbox --json` output ---

#[derive(Debug, Clone, Default, Deserialize)]
pub struct MailMessage {
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub from: String,
    #[serde(default)]
    pub to: String,
    #[serde(default)]
    pub subject: String,
    #[serde(default)]
    pub body: String,
    #[serde(default)]
    pub timestamp: String,
    #[serde(default)]
    pub read: bool,
    #[serde(default)]
    pub priority: String,
    #[serde(default, rename = "type")]
    pub mail_type: String,
    #[serde(default)]
    pub thread_id: String,
}

// --- CLI docs (generated by cobra docgen) ---

#[derive(Debug, Clone, Default, Deserialize)]
pub struct CliCommand {
    #[serde(default)]
    pub cmd: String,
    #[serde(default)]
    pub short: String,
    #[serde(default)]
    pub synopsis: String,
    #[serde(default)]
    pub usage: String,
    #[serde(default)]
    pub options: String,
    #[serde(default)]
    pub subcommands: Vec<CliSubcommand>,
    #[serde(default)]
    pub is_parent: bool,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct CliSubcommand {
    #[serde(default)]
    pub cmd: String,
    #[serde(default)]
    pub desc: String,
}

#[derive(Debug, Clone, Default, Deserialize)]
struct CliDocsIndex {
    #[serde(default)]
    pub commands: Vec<CliCommand>,
}

/// Load the CLI docs index from the embedded JSON file.
pub fn load_cli_docs() -> Vec<CliCommand> {
    let json = include_str!("../gt-cli-docs.json");
    match serde_json::from_str::<CliDocsIndex>(json) {
        Ok(index) => index.commands,
        Err(_) => Vec::new(),
    }
}

// --- CLI helpers ---

fn run_bd(args: &[&str]) -> Option<String> {
    let result = Command::new("bd")
        .arg("--no-db")
        .args(args)
        .output()
        .ok()?;
    let stdout = String::from_utf8_lossy(&result.stdout).to_string();
    if !stdout.trim().is_empty() {
        Some(stdout)
    } else {
        None
    }
}

fn run_gt(args: &[&str]) -> Option<String> {
    let result = Command::new("gt")
        .args(args)
        .output()
        .ok()?;
    if result.status.success() {
        Some(String::from_utf8_lossy(&result.stdout).to_string())
    } else {
        // Some gt commands write JSON to stderr for non-zero exits
        let stdout = String::from_utf8_lossy(&result.stdout);
        if !stdout.trim().is_empty() {
            Some(stdout.to_string())
        } else {
            None
        }
    }
}

/// Run a CLI command string like "gt status" or "bd ready".
/// Returns the output (stdout, or stderr on failure, or error message).
pub fn run_cli_command(cmd: &str) -> String {
    let parts: Vec<&str> = cmd.split_whitespace().collect();
    if parts.is_empty() {
        return "(empty command)".to_string();
    }
    let (program, args) = if parts[0] == "bd" {
        // bd commands need --no-db
        ("bd", {
            let mut a = vec!["--no-db"];
            a.extend_from_slice(&parts[1..]);
            a
        })
    } else {
        (parts[0], parts[1..].to_vec())
    };

    match Command::new(program).args(&args).output() {
        Ok(result) => {
            let stdout = String::from_utf8_lossy(&result.stdout);
            let stderr = String::from_utf8_lossy(&result.stderr);
            if !stdout.trim().is_empty() {
                stdout.to_string()
            } else if !stderr.trim().is_empty() {
                stderr.to_string()
            } else if result.status.success() {
                "(no output)".to_string()
            } else {
                format!("exit code: {}", result.status.code().unwrap_or(-1))
            }
        }
        Err(e) => format!("error: {e}"),
    }
}

pub fn fetch_status() -> TownStatus {
    if let Some(output) = run_gt(&["status", "--json"]) {
        // Skip warning lines (start with WARNING or whitespace before JSON)
        let json_start = output.find('{').unwrap_or(0);
        let json = &output[json_start..];
        if let Ok(status) = serde_json::from_str::<TownStatus>(json) {
            return status;
        }
    }

    TownStatus {
        name: "Gas Town".to_string(),
        ..Default::default()
    }
}

pub fn fetch_convoys() -> Vec<ConvoyItem> {
    if let Some(output) = run_gt(&["convoy", "list", "--json"]) {
        let json_start = output.find('[').or_else(|| output.find('{')).unwrap_or(0);
        let json = &output[json_start..];
        if let Ok(items) = serde_json::from_str::<Vec<ConvoyItem>>(json) {
            return items;
        }
    }
    Vec::new()
}

fn parse_bd_json<T: serde::de::DeserializeOwned>(output: &str) -> Vec<T> {
    // bd output may have warnings before JSON; find the array start
    let json_start = output.find('[').unwrap_or(0);
    let json = &output[json_start..];
    serde_json::from_str::<Vec<T>>(json).unwrap_or_default()
}

pub fn fetch_beads() -> BeadsSnapshot {
    let ready = run_bd(&["ready", "--json"])
        .map(|o| parse_bd_json::<BeadItem>(&o))
        .unwrap_or_default();

    let in_progress = run_bd(&["list", "--json", "--status", "in_progress"])
        .map(|o| parse_bd_json::<BeadItem>(&o))
        .unwrap_or_default();

    let blocked = run_bd(&["blocked", "--json"])
        .map(|o| parse_bd_json::<BeadItem>(&o))
        .unwrap_or_default();

    let total_count = run_bd(&["count", "--json"])
        .and_then(|o| {
            let start = o.find('{').unwrap_or(0);
            let val: serde_json::Value = serde_json::from_str(&o[start..]).ok()?;
            val.get("count").and_then(|v| v.as_u64()).map(|n| n as u32)
        })
        .unwrap_or(0);

    BeadsSnapshot {
        ready,
        in_progress,
        blocked,
        total_count,
    }
}

pub fn fetch_mail() -> Vec<MailMessage> {
    if let Some(output) = run_gt(&["mail", "inbox", "--json"]) {
        let json_start = output.find('[').unwrap_or(0);
        let json = &output[json_start..];
        if let Ok(messages) = serde_json::from_str::<Vec<MailMessage>>(json) {
            return messages;
        }
    }
    Vec::new()
}

fn parse_event_line(line: &str) -> Option<GtEvent> {
    let val: serde_json::Value = serde_json::from_str(line).ok()?;
    Some(GtEvent {
        timestamp: val.get("timestamp").and_then(|v| v.as_str()).unwrap_or("").to_string(),
        event_type: val.get("type").and_then(|v| v.as_str()).unwrap_or("event").to_string(),
        actor: val.get("actor").and_then(|v| v.as_str()).unwrap_or("").to_string(),
        message: val.get("message").and_then(|v| v.as_str()).unwrap_or("").to_string(),
    })
}

// --- Subscriptions ---

pub struct StatusPoller;

impl Subscription<Msg> for StatusPoller {
    fn id(&self) -> SubId {
        0x5354_4154 // "STAT"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let status = fetch_status();
            if sender.send(Msg::StatusRefresh(status)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(5)) {
                break;
            }
        }
    }
}

pub struct ConvoyPoller;

impl Subscription<Msg> for ConvoyPoller {
    fn id(&self) -> SubId {
        0x434F_4E56 // "CONV"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let convoys = fetch_convoys();
            if sender.send(Msg::ConvoyRefresh(convoys)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(10)) {
                break;
            }
        }
    }
}

pub struct BeadsPoller;

impl Subscription<Msg> for BeadsPoller {
    fn id(&self) -> SubId {
        0x4245_4144 // "BEAD"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let snapshot = fetch_beads();
            if sender.send(Msg::BeadsRefresh(snapshot)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(15)) {
                break;
            }
        }
    }
}

pub struct MailPoller;

impl Subscription<Msg> for MailPoller {
    fn id(&self) -> SubId {
        0x4D41_494C // "MAIL"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let messages = fetch_mail();
            if sender.send(Msg::MailRefresh(messages)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(30)) {
                break;
            }
        }
    }
}

/// Polls tmux server state every 3 seconds.
/// Only useful when on the TmuxCommander screen.
pub struct TmuxPoller;

impl Subscription<Msg> for TmuxPoller {
    fn id(&self) -> SubId {
        0x544D_5558 // "TMUX"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let snapshot = crate::tmux::model::fetch_tmux_snapshot();
            if sender.send(Msg::TmuxSnapshot(snapshot)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(3)) {
                break;
            }
        }
    }
}

/// Polls tmuxrs config directory every 10 seconds.
/// Only useful when on the LayoutManager screen.
pub struct TmuxrsConfigPoller;

impl Subscription<Msg> for TmuxrsConfigPoller {
    fn id(&self) -> SubId {
        0x544D_5253 // "TMRS"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        loop {
            let configs = crate::tmuxrs::cli::list_configs().unwrap_or_default();
            if sender.send(Msg::TmuxrsConfigList(configs)).is_err() {
                break;
            }
            // Also refresh live tmux session list
            let sessions: Vec<String> = crate::tmux::client::list_sessions()
                .unwrap_or_default()
                .into_iter()
                .map(|s| s.name)
                .collect();
            if sender.send(Msg::TmuxSessionList(sessions)).is_err() {
                break;
            }
            if stop.wait_timeout(Duration::from_secs(10)) {
                break;
            }
        }
    }
}

pub struct EventTailer;

impl Subscription<Msg> for EventTailer {
    fn id(&self) -> SubId {
        0x4556_4E54 // "EVNT"
    }

    fn run(&self, sender: mpsc::Sender<Msg>, stop: StopSignal) {
        let path = PathBuf::from(std::env::var("HOME").unwrap_or_else(|_| "/home/ubuntu".to_string()))
            .join(".events.jsonl");

        let file = match std::fs::File::open(&path) {
            Ok(f) => f,
            Err(_) => {
                // No events file yet, poll until it appears
                loop {
                    if stop.wait_timeout(Duration::from_secs(2)) {
                        return;
                    }
                    if path.exists() {
                        break;
                    }
                }
                match std::fs::File::open(&path) {
                    Ok(f) => f,
                    Err(_) => return,
                }
            }
        };

        let mut reader = BufReader::new(file);
        // Seek to end to only get new events
        let _ = reader.seek(SeekFrom::End(0));

        let mut line = String::new();
        loop {
            line.clear();
            match reader.read_line(&mut line) {
                Ok(0) => {
                    // No new data, wait briefly
                    if stop.wait_timeout(Duration::from_millis(500)) {
                        break;
                    }
                }
                Ok(_) => {
                    let trimmed = line.trim();
                    if !trimmed.is_empty() {
                        if let Some(event) = parse_event_line(trimmed) {
                            if sender.send(Msg::NewEvent(event)).is_err() {
                                break;
                            }
                        }
                    }
                }
                Err(_) => {
                    if stop.wait_timeout(Duration::from_secs(1)) {
                        break;
                    }
                }
            }
        }
    }
}
