<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FrankenTUI — Showcase Demo</title>
<link rel="preload" href="./fonts/pragmasevka-nf-subset.woff2" as="font" type="font/woff2" crossorigin>
<style>
	  @font-face {
	    font-family: "Pragmasevka NF";
	    src: url("./fonts/pragmasevka-nf-subset.woff2") format("woff2");
	    font-weight: 400;
	    font-style: normal;
	    font-display: block;
	  }
	  * { margin: 0; padding: 0; box-sizing: border-box; }
	  html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; }
	  #container {
	    width: 100%; height: 100%;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
  }
  #terminal-canvas {
    display: block;
    width: 100%; height: 100%;
    image-rendering: pixelated;
  }
	  #status {
	    position: fixed; bottom: 8px; right: 12px;
	    color: #666; font: 12px/1 "Pragmasevka NF", monospace;
	    pointer-events: none; z-index: 10;
	  }
	  #error-overlay {
	    display: none;
	    position: fixed; inset: 0;
	    background: rgba(0,0,0,0.85);
	    color: #f44; font: 16px/1.5 "Pragmasevka NF", monospace;
	    padding: 32px; overflow: auto; z-index: 20;
	  }
	  #error-overlay.visible { display: block; }
	  /* ── Loading overlay ─────────────────────────────────────────────── */
	  #loading-overlay {
	    position: fixed; inset: 0;
	    background: #0a0a0a;
	    display: flex; flex-direction: column;
	    align-items: center; justify-content: center;
	    z-index: 30; transition: opacity 0.3s;
	  }
	  #loading-overlay.hidden { opacity: 0; pointer-events: none; }
	  #loading-label {
	    color: #888; font: 14px/1.4 "Pragmasevka NF", monospace;
	    margin-bottom: 16px;
	  }
	  #loading-bar-container {
	    width: 320px; max-width: 80vw; height: 4px;
	    background: #222; border-radius: 2px; overflow: hidden;
	  }
	  #loading-bar {
	    height: 100%; width: 0%;
	    background: #4a9; border-radius: 2px;
	    transition: width 0.15s ease-out;
	  }
	  #loading-bar.indeterminate {
	    width: 30%;
	    animation: indeterminate 1.2s ease-in-out infinite;
	  }
	  @keyframes indeterminate {
	    0%   { transform: translateX(-100%); }
	    100% { transform: translateX(400%); }
	  }
</style>
</head>
<body>
<div id="container">
  <canvas id="terminal-canvas" tabindex="0"></canvas>
</div>
<div id="loading-overlay">
  <div id="loading-label">Loading WASM...</div>
  <div id="loading-bar-container"><div id="loading-bar"></div></div>
</div>
<div id="status">Loading WASM...</div>
<div id="error-overlay"></div>

<script type="module">
// ── URL Settings ──────────────────────────────────────────────────────
const params = new URLSearchParams(window.location.search);
const INITIAL_COLS    = parseInt(params.get("cols"), 10) || 80;
const INITIAL_ROWS    = parseInt(params.get("rows"), 10) || 24;
const CELL_WIDTH      = parseInt(params.get("cellWidth"), 10) || 8;
const CELL_HEIGHT     = parseInt(params.get("cellHeight"), 10) || 16;
const START_SCREEN    = parseInt(params.get("screen"), 10) || 0;
const URL_ZOOM        = parseFloat(params.get("zoom")) || 0;
const LOG_JSONL       = true;   // Emit JSONL evidence to console
const LOG_PERF        = false;  // Per-frame timing in console
// Bump when deploying to bypass Cloudflare/browser caches for JS/WASM artifacts.
const ASSET_VERSION = "2026-02-10.7";

// ── DOM refs ───────────────────────────────────────────────────────────
const canvas         = document.getElementById("terminal-canvas");
const status         = document.getElementById("status");
const errorDiv       = document.getElementById("error-overlay");
const loadingOverlay = document.getElementById("loading-overlay");
const loadingLabel   = document.getElementById("loading-label");
const loadingBar     = document.getElementById("loading-bar");

function showError(msg) {
  errorDiv.textContent = msg;
  errorDiv.classList.add("visible");
  loadingOverlay.classList.add("hidden");
  status.textContent = "Error";
  console.error("[ShowcaseDemo]", msg);
}

function setProgress(pct, label) {
  loadingLabel.textContent = label;
  if (pct < 0) {
    // Indeterminate mode.
    loadingBar.classList.add("indeterminate");
    loadingBar.style.width = "";
  } else {
    loadingBar.classList.remove("indeterminate");
    loadingBar.style.width = Math.min(100, Math.round(pct)) + "%";
  }
}

// ── Fetch with progress ───────────────────────────────────────────────
async function fetchWithProgress(url, label) {
  const response = await fetch(url);
  if (!response.ok) throw new Error(`GET ${url} -> ${response.status}`);
  const contentLength = parseInt(response.headers.get("content-length"), 10);
  if (!contentLength || !response.body) {
    setProgress(-1, label);
    return new Uint8Array(await response.arrayBuffer());
  }
  const reader = response.body.getReader();
  const chunks = [];
  let received = 0;
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    received += value.length;
    setProgress((received / contentLength) * 100, `${label} (${(received / 1048576).toFixed(1)} MB)`);
  }
  const result = new Uint8Array(received);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result;
}

// ── Font loading (must happen before first glyph rasterization) ───────────
const fontsReady = (async () => {
  if (!("fonts" in document) || !document.fonts?.load) return;
  try {
    await document.fonts.load('16px "Pragmasevka NF"');
    await document.fonts.ready;
  } catch (e) {
    console.warn("[ShowcaseDemo] Font load failed; continuing with fallback.", e);
  }
})();

// ── Large text assets (loaded out-of-band to keep WASM small) ────────────
// These blobs are huge (multiple MB). Embedding them in WASM bloats downloads
// and, worse, slows instantiation due to large data-segment memcpy.
const largeAssetsPromise = (async () => {
  try {
    const shakespeareUrl = `./crates/ftui-demo-showcase/data/shakespeare.txt?v=${ASSET_VERSION}`;
    const sqliteUrl      = `./crates/ftui-demo-showcase/data/sqlite3.c?v=${ASSET_VERSION}`;
    const [shakespeare, sqlite] = await Promise.all([
      fetch(shakespeareUrl).then((r) => {
        if (!r.ok) throw new Error(`GET ${shakespeareUrl} -> ${r.status}`);
        return r.text();
      }),
      fetch(sqliteUrl).then((r) => {
        if (!r.ok) throw new Error(`GET ${sqliteUrl} -> ${r.status}`);
        return r.text();
      }),
    ]);
    return { shakespeare, sqlite };
  } catch (e) {
    console.warn("[ShowcaseDemo] Failed to fetch large assets; some screens may be unavailable.", e);
    return null;
  }
})();

// ── WASM module loading with progress ─────────────────────────────────
// Phase 1: Download WASM binaries with progress tracking.
// Phase 2: Compile WASM modules.
// Phase 3: Initialize (instantiate + link imports).
let termMod, runnerMod;
try {
  // 1a. Download JS glue modules.
  setProgress(0, "Downloading JS modules...");
  const termJsUrl = `./pkg/FrankenTerm.js?v=${ASSET_VERSION}`;
  const runnerJsUrl = `./pkg/ftui_showcase_wasm.js?v=${ASSET_VERSION}`;
  [termMod, runnerMod] = await Promise.all([
    import(termJsUrl),
    import(runnerJsUrl),
  ]);

  // 1b. Download WASM binaries with progress.
  setProgress(5, "Downloading WASM...");
  const termWasmUrl = `./pkg/FrankenTerm_bg.wasm?v=${ASSET_VERSION}`;
  const runnerWasmUrl = `./pkg/ftui_showcase_wasm_bg.wasm?v=${ASSET_VERSION}`;

  const [termWasm, runnerWasm] = await Promise.all([
    fetchWithProgress(termWasmUrl, "Downloading terminal WASM..."),
    fetchWithProgress(runnerWasmUrl, "Downloading showcase WASM..."),
  ]);

  // 2. Compile WASM modules.
  setProgress(-1, "Compiling WASM...");
  const [termCompiled, runnerCompiled] = await Promise.all([
    WebAssembly.compile(termWasm),
    WebAssembly.compile(runnerWasm),
  ]);

  // 3. Initialize (instantiate) both modules.
  setProgress(90, "Initializing...");
  await Promise.all([
    termMod.default(termCompiled),
    runnerMod.default(runnerCompiled),
  ]);
  setProgress(95, "Starting WebGPU...");
} catch (e) {
  showError(
    `Failed to load WASM modules.\n\n` +
    `Expected wasm-pack output at ./pkg/FrankenTerm.js and ./pkg/ftui_showcase_wasm.js\n\n` +
    `Build with:\n` +
    `  ./build-wasm.sh\n\n` +
    `Error: ${e.message || e}`
  );
  throw e;
}

// ── Create instances ───────────────────────────────────────────────────
const { FrankenTermWeb }  = termMod;
const { ShowcaseRunner }  = runnerMod;

const term   = new FrankenTermWeb();
const dpr    = window.devicePixelRatio || 1.0;

try {
  await fontsReady;
  setProgress(96, "Initializing WebGPU terminal...");
  await term.init(canvas, {
    cols: INITIAL_COLS,
    rows: INITIAL_ROWS,
    cellWidth: CELL_WIDTH,
    cellHeight: CELL_HEIGHT,
    dpr,
    focused: true,
  });
} catch (e) {
  showError(`FrankenTermWeb.init() failed: ${e.message || e}\n\nWebGPU may not be supported in this browser.`);
  throw e;
}

// ── User zoom (Ctrl+/- font sizing) ──────────────────────────────────
let userZoom = URL_ZOOM || parseFloat(localStorage.getItem("ftui-zoom")) || 1.0;

function applyZoom() {
  if (typeof term.setZoom === "function") {
    term.setZoom(userZoom);
  }
  const newDpr = window.devicePixelRatio || 1.0;
  const geo = term.fitToContainer(container.clientWidth, container.clientHeight, newDpr);
  if (geo.cols !== currentCols || geo.rows !== currentRows) {
    currentCols = geo.cols;
    currentRows = geo.rows;
    runner.resize(currentCols, currentRows);
    status.textContent = `${currentCols}\u00d7${currentRows} \u2014 zoom ${Math.round(userZoom * 100)}%`;
  }
  localStorage.setItem("ftui-zoom", String(userZoom));
  // Update URL without reload.
  const url = new URL(window.location);
  if (Math.abs(userZoom - 1.0) > 0.01) {
    url.searchParams.set("zoom", userZoom.toFixed(2));
  } else {
    url.searchParams.delete("zoom");
  }
  history.replaceState(null, "", url);
}

// Apply initial zoom if set.
if (userZoom !== 1.0 && typeof term.setZoom === "function") {
  term.setZoom(userZoom);
}

// Fit to actual container size and get real cols/rows.
const container = document.getElementById("container");
const geo = term.fitToContainer(container.clientWidth, container.clientHeight, dpr);
let currentCols = geo.cols;
let currentRows = geo.rows;

const runner = new ShowcaseRunner(currentCols, currentRows);
runner.init();

// Navigate to a specific screen if requested via URL.
if (START_SCREEN > 0) {
  const screenIdx = START_SCREEN - 1;
  // Send number key press to navigate: '1'-'9' for screens 1-9, '0' for 10.
  // For screens > 10, we send repeated Tab presses.
  if (screenIdx < 10) {
    const key = screenIdx === 9 ? "0" : String(screenIdx + 1);
    runner.pushEncodedInput(JSON.stringify({ kind: "key", phase: "down", key, code: `Digit${key}`, mods: 0, repeat: false }));
  } else {
    // Navigate with Tab presses.
    for (let i = 0; i < screenIdx; i++) {
      runner.pushEncodedInput(JSON.stringify({ kind: "key", phase: "down", key: "Tab", code: "Tab", mods: 0, repeat: false }));
    }
  }
}

// `ShowcaseRunner.init()` renders frame 1 and produces a full repaint patch batch.
// If we don't apply it immediately, the first `step()` often returns `rendered=false`
// and the initial frame never becomes visible (or later diffs apply against an empty buffer).
const initPatches = runner.takeFlatPatches();
if (initPatches.cells.length > 0) {
  term.applyPatchBatchFlat(initPatches.spans, initPatches.cells);
}
term.render();

// Hide loading overlay, show status.
setProgress(100, "Ready");
loadingOverlay.classList.add("hidden");
status.textContent = `${currentCols}\u00d7${currentRows} \u2014 running`;

// Inject large text assets after first frame so startup work is not blocked.
largeAssetsPromise.then((assets) => {
  if (!assets) return;
  try {
    const okA = runner.setShakespeareText(assets.shakespeare);
    const okB = runner.setSqliteSource(assets.sqlite);
    jsonl({
      event: "assets_loaded",
      shakespeare_bytes: assets.shakespeare.length,
      sqlite_bytes: assets.sqlite.length,
      ok: Boolean(okA && okB),
      ts: Date.now(),
    });
  } catch (e) {
    console.warn("[ShowcaseDemo] Failed to inject large assets into WASM runner.", e);
  }
});

// ── JSONL logger ───────────────────────────────────────────────────────
function jsonl(obj) {
  if (LOG_JSONL) console.log(JSON.stringify(obj));
}

jsonl({ event: "init", cols: currentCols, rows: currentRows, dpr, zoom: userZoom, ts: Date.now() });

// ── Resize handling ────────────────────────────────────────────────────
const resizeObserver = new ResizeObserver(() => {
  const newDpr = window.devicePixelRatio || 1.0;
  const geo = term.fitToContainer(container.clientWidth, container.clientHeight, newDpr);
  if (geo.cols !== currentCols || geo.rows !== currentRows) {
    currentCols = geo.cols;
    currentRows = geo.rows;
    runner.resize(currentCols, currentRows);
    jsonl({ event: "resize", cols: currentCols, rows: currentRows, ts: Date.now() });
    status.textContent = `${currentCols}\u00d7${currentRows} \u2014 running`;
  }
});
resizeObserver.observe(container);

// Handle DPR changes via visualViewport API (more reliable than matchMedia).
if (window.visualViewport) {
  window.visualViewport.addEventListener("resize", () => {
    const newDpr = window.devicePixelRatio || 1.0;
    const geo = term.fitToContainer(container.clientWidth, container.clientHeight, newDpr);
    if (geo.cols !== currentCols || geo.rows !== currentRows) {
      currentCols = geo.cols;
      currentRows = geo.rows;
      runner.resize(currentCols, currentRows);
    }
  });
} else {
  // Fallback: matchMedia for DPR changes (only fires once per threshold).
  window.matchMedia(`(resolution: ${dpr}dppx)`).addEventListener("change", () => {
    const newDpr = window.devicePixelRatio || 1.0;
    const geo = term.fitToContainer(container.clientWidth, container.clientHeight, newDpr);
    if (geo.cols !== currentCols || geo.rows !== currentRows) {
      currentCols = geo.cols;
      currentRows = geo.rows;
      runner.resize(currentCols, currentRows);
    }
  });
}

// ── Input forwarding ───────────────────────────────────────────────────
// DOM events -> FrankenTermWeb.input() -> drainEncodedInputs() -> runner

function safeTermInput(ev) {
  try {
    term.input(ev);
  } catch (e) {
    console.error("[ShowcaseDemo] term.input failed:", e, ev);
  }
}

function domKeyToInput(e, phase) {
  return {
    kind: "key",
    phase,
    // `key` and `code` are both required by `frankenterm-web` wasm bindings.
    // - key: logical key value (e.g. "a", "Enter")
    // - code: physical key code (e.g. "KeyA", "Enter")
    key: (typeof e.key === "string") ? e.key : "",
    code: (typeof e.code === "string") ? e.code : "",
    mods: (e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0),
    repeat: e.repeat || false,
  };
}

function domMouseToInput(e, phase) {
  const rect = canvas.getBoundingClientRect();
  const cellW = rect.width / currentCols;
  const cellH = rect.height / currentRows;
  const x = Math.floor((e.clientX - rect.left) / cellW);
  const y = Math.floor((e.clientY - rect.top)  / cellH);
  return {
    kind: "mouse",
    phase,
    button: e.button,
    x: Math.max(0, Math.min(x, currentCols - 1)),
    y: Math.max(0, Math.min(y, currentRows - 1)),
    mods: (e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0),
  };
}

function domWheelToInput(e) {
  const rect = canvas.getBoundingClientRect();
  const cellW = rect.width / currentCols;
  const cellH = rect.height / currentRows;
  const x = Math.floor((e.clientX - rect.left) / cellW);
  const y = Math.floor((e.clientY - rect.top)  / cellH);
  return {
    kind: "wheel",
    x: Math.max(0, Math.min(x, currentCols - 1)),
    y: Math.max(0, Math.min(y, currentRows - 1)),
    dx: Math.round(e.deltaX),
    dy: Math.round(e.deltaY),
    mods: (e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0),
  };
}

function shouldForwardKeyEvent(e) {
  // Avoid double-encoding during IME composition.
  return !(e.isComposing || e.key === "Process");
}

// Intercept Ctrl+/- for zoom, forward everything else to the terminal.
window.addEventListener("keydown", (e) => {
  if (!shouldForwardKeyEvent(e)) return;

  // Ctrl+Plus / Ctrl+Equal: zoom in.
  if (e.ctrlKey && (e.key === "+" || e.key === "=")) {
    e.preventDefault();
    userZoom = Math.min(3.0, userZoom * 1.1);
    applyZoom();
    return;
  }
  // Ctrl+Minus: zoom out.
  if (e.ctrlKey && e.key === "-") {
    e.preventDefault();
    userZoom = Math.max(0.3, userZoom / 1.1);
    applyZoom();
    return;
  }
  // Ctrl+0: reset zoom.
  if (e.ctrlKey && e.key === "0") {
    e.preventDefault();
    userZoom = 1.0;
    applyZoom();
    return;
  }

  e.preventDefault();
  safeTermInput(domKeyToInput(e, "down"));
}, { capture: true });

window.addEventListener("keyup", (e) => {
  if (!shouldForwardKeyEvent(e)) return;
  e.preventDefault();
  safeTermInput(domKeyToInput(e, "up"));
}, { capture: true });

canvas.addEventListener("mousedown", (e) => {
  canvas.focus();
  safeTermInput(domMouseToInput(e, "down"));
});
canvas.addEventListener("mouseup", (e) => {
  safeTermInput(domMouseToInput(e, "up"));
});
canvas.addEventListener("mousemove", (e) => {
  safeTermInput(domMouseToInput(e, "move"));
});
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  safeTermInput(domWheelToInput(e));
}, { passive: false });
window.addEventListener("paste", (e) => {
  const text = (e.clipboardData || window.clipboardData).getData("text");
  if (text) safeTermInput({ kind: "paste", data: text });
}, { capture: true });
canvas.addEventListener("focus", () => { safeTermInput({ kind: "focus", focused: true }); });
canvas.addEventListener("blur",  () => { safeTermInput({ kind: "focus", focused: false }); });

window.addEventListener("blur", () => { safeTermInput({ kind: "focus", focused: false }); });
window.addEventListener("focus", () => { safeTermInput({ kind: "focus", focused: true }); });
document.addEventListener("visibilitychange", () => {
  safeTermInput({ kind: "focus", focused: !document.hidden });
});

// Composition (IME) events.
canvas.addEventListener("compositionstart", () => {
  safeTermInput({ kind: "composition", phase: "start" });
});
canvas.addEventListener("compositionupdate", (e) => {
  safeTermInput({ kind: "composition", phase: "update", data: e.data || "" });
});
canvas.addEventListener("compositionend", (e) => {
  safeTermInput({ kind: "composition", phase: "end", data: e.data || "" });
});

// ── Host frame loop ────────────────────────────────────────────────────
let lastTs = 0;
let totalFrames = 0;

function frame(timestamp) {
  const dt = lastTs === 0 ? 16.0 : timestamp - lastTs;
  lastTs = timestamp;

  // 1. Advance deterministic clock.
  runner.advanceTime(dt);

  // 2. Drain normalized inputs from FrankenTermWeb -> push to runner.
  const inputs = term.drainEncodedInputs();
  for (let i = 0; i < inputs.length; i++) {
    runner.pushEncodedInput(inputs[i]);
  }

  // 3. Step the application.
  const result = runner.step();

  // 4. If a frame was rendered, apply patches and present.
  if (result.rendered) {
    const patches = runner.takeFlatPatches();
    if (patches.cells.length > 0) {
      term.applyPatchBatchFlat(patches.spans, patches.cells);
    }
    term.render();
    totalFrames++;

    if (LOG_JSONL) {
      const stats = runner.patchStats();
      jsonl({
        event: "frame",
        frame_idx: result.frame_idx,
        events_processed: result.events_processed,
        patch_hash: runner.patchHash(),
        dirty_cells: stats ? stats.dirty_cells : 0,
        patch_count: stats ? stats.patch_count : 0,
        ts: Date.now(),
      });
    }
  }

  // 5. Drain logs.
  const logs = runner.takeLogs();
  for (let i = 0; i < logs.length; i++) {
    jsonl({ event: "log", text: logs[i], frame_idx: result.frame_idx, ts: Date.now() });
  }

  // 6. Continue or stop.
  if (result.running) {
    requestAnimationFrame(frame);
  } else {
    status.textContent = `${currentCols}\u00d7${currentRows} \u2014 stopped (${totalFrames} frames)`;
    jsonl({ event: "quit", total_frames: totalFrames, ts: Date.now() });
    runner.destroy();
  }
}

// Focus the canvas and start.
canvas.focus();
requestAnimationFrame(frame);
</script>
</body>
</html>
